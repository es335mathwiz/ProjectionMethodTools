Get["paperFocus.mth"]

(*one non zero z*)
nfp$0$0=nonFPart[xxtm1={{qtm1},{rtm1},{rutm1}},{{eps}},bmat,phimat,psieps]//numIt//Chop;
fp$0$0=fPart[phimat,fmat,psiz,0,1]//numIt;
x$0$0=nfp$0$0+fp$0$0

x$0$1=nonFPart[x$0$0,{{0}},bmat,phimat,psieps]//numIt//Chop;
hmat . Join[xxtm1,x$0$0,x$0$1]//numIt//Expand


(*two non zero z's*)
nfp$1$0=nonFPart[xxtm1={{qtm1},{rtm1},{rutm1}},{{eps}},bmat,phimat,psieps]//numIt//Chop;
fp$1$0=fPart[phimat,fmat,psiz,1,1]//numIt;
x$1$0=nfp$1$0+fp$1$0

nfp$1$1=nonFPart[x$1$0,{{0}},bmat,phimat,psieps]//numIt//Chop;
fp$1$1=fPart[phimat,fmat,psiz,0,1]/.zzz$0$1[t]->zzz$1$1[t]//numIt;
x$1$1=nfp$1$1+fp$1$1;
x$1$2=nonFPart[x$1$1,{{0}},bmat,phimat,psieps]//numIt//Chop;
hmat . Join[xxtm1,x$1$0,x$1$1]//numIt//Expand
hmat . Join[x$1$0,x$1$1,x$1$2]//numIt//Expand






(*three non zero z's*)
nfp$2$0=nonFPart[xxtm1={{qtm1},{rtm1},{rutm1}},{{eps}},bmat,phimat,psieps]//numIt//Chop;
fp$2$0=fPart[phimat,fmat,psiz,2,1]//numIt;
x$2$0=nfp$2$0+fp$2$0

nfp$2$1=nonFPart[x$2$0,{{0}},bmat,phimat,psieps]//numIt//Chop;
fp$2$1=fPart[phimat,fmat,psiz,1,1]/.{zzz$1$1[t]->zzz$2$1[t],zzz$0$1[t]->zzz$1$1[t]}//numIt;
x$2$1=nfp$2$1+fp$2$1;
nfp$2$2=nonFPart[x$2$1,{{0}},bmat,phimat,psieps]//numIt//Chop;
fp$2$2=fPart[phimat,fmat,psiz,0,1]/.{zzz$0$1[t]->zzz$2$1[t]}//numIt;
x$2$2=nfp$2$2+fp$2$2;

nfp$2$3=nonFPart[x$2$2,{{0}},bmat,phimat,psieps]//numIt//Chop;
x$2$3=nfp$2$3;
hmat . Join[xxtm1,x$2$0,x$2$1]//numIt//Expand
hmat . Join[x$2$0,x$2$1,x$2$2]//numIt//Expand
hmat . Join[x$2$1,x$2$2,x$2$3]//numIt//Expand


genPath[numNonZeroZs_Integer]:=
With[{xtm1={{qtm1},{rtm1},{rutm1}},
rawFParts=Reverse[(redoFPart[phimat,fmat,psiz,#,1,0] &/@Range[0,numNonZeroZs-1])//numIt]},
With[{bgn=(nonFPart[xtm1,
{{eps}},bmat,phimat,psieps]+rawFParts[[1]])//numIt},
Join[xtm1,Join @@ FoldList[(nonFPart[#1,{{0}},bmat,phimat,psieps]+#2//numIt)&,
bgn,Drop[rawFParts,1]]]]]

(* close but no cigar hmat .  genPath[2] //numIt*)

(*solve for constraint in second equation using x$0$0 *)
(* one period constraint*)
soln$1=Solve[
{qt==x$0$0[[1,1]],rut==x$0$0[[3,1]],rUnderBar==x$0$0[[2,1]]}//numIt,
{qt,rut,zzz$0$1[t]}]


(* two period constraint*)

zSub$2=(Cases[soln$1,HoldPattern[zzz$0$1[t]->_],Infinity]/.
{zzz$0$1[t]->zzz$1$1[t],qtm1->qt,rutm1->rut,eps->0});
xSubbed=x$1$0/.zSub$2//Expand
soln$2=Solve[
{qt==xSubbed[[1,1]],rut==xSubbed[[3,1]],rUnderBar==xSubbed[[2,1]]}//numIt,
{qt,rut,zzz$0$1[t]}]

x$1$1=nfp$1$1+fp$1$1;
x$1$2=nonFPart[x$1$1,{{0}},bmat,phimat,psieps]//numIt//Chop;
x$1$3=nonFPart[x$1$2,{{0}},bmat,phimat,psieps]//numIt//Chop;

xReSubbed$1=(Join[xxtm1,x$1$0,x$1$1]/.zSub$2)/.soln$2[[1]];
((hmat . xReSubbed$1//numIt//Expand) -(psiz . {{ zzz$0$1[t]}}/.soln$2[[1]]) -( psieps . {{eps}}))//numIt//Chop

xReSubbed$2=(Join[x$1$0,x$1$1,x$1$2]/.zSub$2)/.soln$2[[1]];
((hmat . xReSubbed$2//numIt//Expand) -((psiz . ({{ zzz$0$1[t]}}/.soln$1[[1]])/.{qtm1->xReSubbed$1[[4,1]],rutm1->xReSubbed$1[[6,1]],eps->0}) +( psieps . {{0}})))//numIt//Chop

xReSubbed$3=(Join[x$1$1,x$1$2,x$1$3]/.zSub$2)/.soln$2[[1]];
(hmat . xReSubbed$3//numIt//Expand) 




(* three period constraint*)


zSub$2=(Cases[soln$1,HoldPattern[zzz$0$1[t]->_],Infinity]/.
{zzz$0$1[t]->zzz$1$1[t],qtm1->qt,rutm1->rut,eps->0});
xSubbed=x$1$0/.zSub$2//Expand
soln$2=Solve[
{qt==xSubbed[[1,1]],rut==xSubbed[[3,1]],rUnderBar==xSubbed[[2,1]]}//numIt,
{qt,rut,zzz$0$1[t]}]

x$1$1=nfp$1$1+fp$1$1;
x$1$2=nonFPart[x$1$1,{{0}},bmat,phimat,psieps]//numIt//Chop;
x$1$3=nonFPart[x$1$2,{{0}},bmat,phimat,psieps]//numIt//Chop;

xReSubbed$1=(Join[xxtm1,x$1$0,x$1$1]/.zSub$2)/.soln$2[[1]];
((hmat . xReSubbed$1//numIt//Expand) -(psiz . {{ zzz$0$1[t]}}/.soln$2[[1]]) -( psieps . {{eps}}))//numIt//Chop

xReSubbed$2=(Join[x$1$0,x$1$1,x$1$2]/.zSub$2)/.soln$2[[1]];
((hmat . xReSubbed$2//numIt//Expand) -((psiz . ({{ zzz$0$1[t]}}/.soln$1[[1]])/.{qtm1->xReSubbed$1[[4,1]],rutm1->xReSubbed$1[[6,1]],eps->0}) +( psieps . {{0}})))//numIt//Chop

xReSubbed$3=(Join[x$1$1,x$1$2,x$1$3]/.zSub$2)/.soln$2[[1]];
(hmat . xReSubbed$3//numIt//Expand) 






(*


augPath[{}]=augPath[]:=
With[{xtm1={{qtm1},{rtm1},{rutm1}}},
With[{nfp=
nonFPart[xtm1,{{eps}},bmat,phimat,psieps]//
numIt//Chop,
fp=fPart[phimat,fmat,psiz,0,1]//numIt},
With[{xt=nfp+fp},
xt]]]


augPath[pathNow_?MatrixQ]:=

With[{theFParts=(fPart[phimat,fmat,psiz,#,1,0]&/@Range[numCons-1,0,-1])//numIt},
theFParts]





unCon0 = fzComp[ {{qq[t]},{rr[t]},{ru[t]}},{{qq[t-1]},{rr[t-1]},{ru[t-1]}},{{uu$Shock}},{{zt0}},{{0}}]/.eqvdIf[xx_,yy_,zz_]:>eqvdIf[xx,zz,zz]




Export["prettyAlways.pdf", MatrixForm[unCon0//. latexSubs]];






Print["got to zt0Subs"]

zt0Subs=Flatten[Solve[unCon0[[-1]],zt0]]/.eqvdIf->If
discrepSubs=Flatten[Solve[unCon0[[-2]],discrep[t]]]/.eqvdIf->If

z1RHS=zt0//.Join[zt0Subs,discrepSubs]//.mySubs//myN//FullSimplify//Chop;
r1RHS=(rr[t]-unCon0[[2,1]])//.Join[zt0Subs,discrepSubs]//.mySubs//myN//FullSimplify//Chop
ru1RHS=(ru[t]-unCon0[[3,1]])//.Join[zt0Subs,discrepSubs]//.mySubs//myN//FullSimplify//Chop
q1RHS=(qq[t]-unCon0[[1,1]])//.Join[zt0Subs,discrepSubs]//.mySubs//myN//FullSimplify//Chop

Export["prettyAlwaysZ1.pdf", MatrixForm[z1RHS//myN//Simplify/. latexSubs]]
Export["prettyAlwaysR1.pdf", MatrixForm[r1RHS//myN//Simplify/. latexSubs]]
Export["prettyAlwaysQ1.pdf", MatrixForm[q1RHS//myN//Simplify/. latexSubs]]
Print["about to compute expectation"]

z1ExpRHS = 
  FullSimplify[
   PiecewiseExpand[
    Expectation[z1RHS //. mySubs, 
     uu$Shock \[Distributed] 
      NormalDistribution[0, sigma$u /. mySubs]]]];

q1ExpRHS = 
  FullSimplify[
   PiecewiseExpand[
    Expectation[q1RHS //. mySubs, 
     uu$Shock \[Distributed] 
      NormalDistribution[0, sigma$u /. mySubs]]]];

r1ExpRHS = 
  FullSimplify[
   PiecewiseExpand[
    Expectation[r1RHS //. mySubs, 
     uu$Shock \[Distributed] 
      NormalDistribution[0, sigma$u /. mySubs]]]];


ru1ExpRHS = 
  FullSimplify[
   PiecewiseExpand[
    Expectation[ru1RHS //. mySubs, 
     uu$Shock \[Distributed] 
      NormalDistribution[0, sigma$u /. mySubs]]]];



erfcFound=Union[Cases[z1ExpRHS, Erfc[___], Infinity]];
erfFound=Union[Cases[z1ExpRHS, Erf[___], Infinity]];




erfSubs = {};




Export["prettyAlwaysZ1EXP.pdf", 
  MatrixForm[z1ExpRHS/. erfSubs /. latexSubs  // Expand]];
Export["prettyAlwaysQ1EXP.pdf", 
  MatrixForm[q1ExpRHS/. erfSubs /. latexSubs  // Expand]];
Export["prettyAlwaysR1EXP.pdf", 
  MatrixForm[r1ExpRHS/. erfSubs /. latexSubs  // Expand]];
Export["prettyAlwaysRu1EXP.pdf", 
  MatrixForm[ru1ExpRHS/. erfSubs /. latexSubs  // Expand]];
Export["prettyAlwaysPsiEps.pdf", 
 MatrixForm[psieps]]; Export["prettyAlwaysPsiZ.pdf", 
 MatrixForm[psiz]]; Export["prettyAlwaysPsiEps.pdf", MatrixForm[psieps]];
Export["prettyAlwaysMuVal.pdf", muVal];

Print["got to end uncommented"]

Print["compute values to sub into system"]
xtm1={{qq[t-1]},{rr[t-1]},{ru[t-1]}};
xt={{q1RHS},{r1RHS},{ru1RHS}};
xtp1=bmat . xt;


xVec=Join[xtm1,xt,xtp1];
resid0=((hmat.xVec//.mySubs) - (psieps*uu$Shock + psiz * z1RHS))//Expand//Chop
Export["prettyAlwaysResid0.pdf", 
  MatrixForm[resid0//Simplify//Chop/. latexSubs]];




Print["solving unCon1"]
RUB=2/100;


unCon1 = ((fzComp[ {{qq[t]},{rr[t]},{ru[t]}},{{qq[t-1]},{rr[t-1]},{ru[t-1]}},{{uu$Shock}},{{zt1}},{{z1ExpRHS/.{qq[t-1]->qq[t],ru[t-1]->ru[t]}}}]/.rUnderBar->RUB//myN)/.eqvdIf[xx_,yy_,zz_]:>eqvdIf[xx,yy,yy])//.mySubs;

Print["got to zt1Subs"]

zt1Subs=Flatten[Solve[unCon1[[-1]],zt1]]/.eqvdIf->If
discrepSubs=Flatten[Solve[unCon1[[-2]],discrep[t]]]/.eqvdIf->If

z2RHS=zt1/.Join[zt1Subs,discrepSubs]/.mySubs//myN//FullSimplify//Chop;


Export["prettyAlwaysZ2RHS.pdf", 
  MatrixForm[z2RHS/. erfSubs /. latexSubs  // Expand]];


sysSubs={uu$Shock->eps[uu][t],zt1->(sqrtZt1[t])};
unCon1A=Chop[((((First/@unCon1)//.mySubs)//myN)/.sysSubs)//ExpandAll];


newWeightedStochasticBasis[lucaMod01, unCon1A];
{{stateVar, nonStateVar, theShock}, modEqns01} = 
  GenerateModelCode[lucaMod01];

polyRange = {{qLow, qHigh}, {ruLow, ruHigh}} //. mySubs;
initPower = {0, 0}; shockPower = {0};
lucaBasis = 
  GenerateBasis[stateVar, polyRange //. mySubs, initPower, theShock,
    theMean //. mySubs, {sigma$u} //. mySubs, 
   integOrder //. mySubs, shockPower, nonStateVar];

simp = JavaNew[
   "gov.frb.ma.msu.ProjectionMethodToolsJava.SimpleFindZeroStrategy"];

modEqns01[updateParams[{RUB(*rUnderBar*)}//.mySubs//myN]]


resZ10$0$0 = 
  ComputeInitialCollocationWeights[lucaBasis, 
   ConstantArray[1, {5, 1}], modEqns01, simp];
resZ10$0$0[isConvergedQ[]]


boo02 = resZ10$0$0[toOrder[{5, 5, 1}]];
If[boo02[isConvergedQ[]], 
polys = Expand[CreatePolynomials[boo02]] // Chop]


TableForm[duh= {(resid0[[1]]/.{rUnderBar->RUB,qq[t-1]->qq,ru[t-1]->ru})/.uu$Shock->.0 ,{qq, qLow, qHigh}, {ru, ruLow, ruHigh}} //. mySubs // myN];Plot3D @@ duh






polySubs={qq[t]->polys[[1]],ru[t]->polys[[2]],qq[t-1]->qq,ru[t-1]->ru};

z2RHSNew=(z2RHS/.rUnderBar->RUB/.discrepSubs)/.polySubs//Simplify

Export["prettyAlwaysZ2RHSNew.pdf", 
  MatrixForm[z2RHSNew/. erfSubs /. latexSubs  // Expand]];



r2RHS=((rr[t]-unCon1[[2,1]])//.Join[zt1Subs,discrepSubs]/.rUnderBar->RUB//.mySubs)/.polySubs//myN//Simplify//Chop
ru2RHS=((ru[t]-unCon1[[3,1]])//.Join[zt1Subs,discrepSubs]//.mySubs)/.polySubs//myN//Simplify//Chop
q2RHS=((qq[t]-unCon1[[1,1]])//.Join[zt1Subs,discrepSubs]//.mySubs)/.polySubs//myN//Simplify//Chop

Export["prettyAlwaysZ2.pdf", MatrixForm[z2RHS//myN//Simplify/. latexSubs]]
Export["prettyAlwaysR2.pdf", MatrixForm[r2RHS//myN//Simplify/. latexSubs]]
Export["prettyAlwaysQ2.pdf", MatrixForm[q2RHS//myN//Simplify/. latexSubs]]

Print["compute values to sub into system"]
xtm1={{qq},{rr},{ru}};
xt={{q2RHS},{r2RHS},{ru2RHS}};
xtp1={{q1ExpRHS},{r1ExpRHS},{ru1ExpRHS}}/.{qq[t-1]->q2RHS,rr[t-1]->r2RHS,ru[t-1]->ru2RHS};
xtp2=bmatCons . ({{q1ExpRHS},{r1ExpRHS},{ru1ExpRHS}}/.{qq[t-1]->q2RHS,rr[t-1]->r2RHS,ru[t-1]->ru2RHS});
xVec=Join[xtm1,xt,xtp1];
xVecTp1=Join[xt,xtp1,xtp2];
resid1=(hmat.xVec//.mySubs)- (psieps*uu$Shock + psiz * z1RHS)//Expand//Chop;
resid1Tp1=(hmat.xVecTp1//.mySubs) - (psieps . {{0}}+ psiz . {{z2RHS}})//Expand//Chop//FullSimplify;
Export["prettyAlwaysResid0.pdf", 
  MatrixForm[resid0/. latexSubs]];






Print["about to compute expectation"]




z2ExpRHS = 
  FullSimplify[
   PiecewiseExpand[
    Expectation[z2RHS //. mySubs, 
     uu$Shock \[Distributed] 
      NormalDistribution[0, sigma$u /. mySubs]]]];

q2ExpRHS = 
  FullSimplify[
   PiecewiseExpand[
    Expectation[q2RHS //. mySubs, 
     uu$Shock \[Distributed] 
      NormalDistribution[0, sigma$u /. mySubs]]]];

r2ExpRHS = 
  FullSimplify[
   PiecewiseExpand[
    Expectation[r2RHS //. mySubs, 
     uu$Shock \[Distributed] 
      NormalDistribution[0, sigma$u /. mySubs]]]];


ru2ExpRHS = 
  FullSimplify[
   PiecewiseExpand[
    Expectation[ru2RHS //. mySubs, 
     uu$Shock \[Distributed] 
      NormalDistribution[0, sigma$u /. mySubs]]]];




{zsub,xtVal}=compZ0[Transpose[{{qtm1,rtm1,rutm1}}],
{{eps}},{{zz}},{{0}}]//.lucaSubs//myN//Expand//Chop



{zsub0,eqns0}=fzIterComp[
Transpose[{{qt,rt,rut}}],Transpose[{{qtm1,rtm1,rutm1}}],
{{eps}},{{zz}},{{0}}]//.lucaSubs//myN//Expand//Chop



{zsub1,eqns1}=fzIterComp[
Transpose[{{qt,rt,rut}}],Transpose[{{qtm1,rtm1,rutm1}}],
{{eps}},{{zz}},{{zz/.zsub0/.{eps->0,qtm1->qt,rtm1->rt,rutm1->rut}}}]//.lucaSubs//myN//Expand//Chop


{zsub1,eqns1}=fzIterComp[
Transpose[{{qt,rt,rut}}],Transpose[{{qtm1,rtm1,rutm1}}],
{{eps}},{{zz2}},{{zz1}}]//.lucaSubs//myN//Expand//Chop



{zsub2,eqns2}=fzIterComp[
Transpose[{{qt,rt,rut}}],Transpose[{{qtm1,rtm1,rutm1}}],
{{eps}},{{zz}},{{zz/.zsub1/.{qtm1->qt,rtm1->rt,rutm1->rut}}}]//.lucaSubs//myN//Expand//Chop




{zsub3,eqns3}=fzIterComp[
Transpose[{{qt,rt,rut}}],Transpose[{{qtm1,rtm1,rutm1}}],
{{eps}},{{zz}},{{zz/.zsub2/.{qtm1->qt,rtm1->rt,rutm1->rut}}}]//.lucaSubs//myN//Expand//Chop


ha=NestList[doIter,{{zz->0},{}},340];


someVecs={{qt},{0.02},{rut}}/.#[[1]]&/@ha;



xtm1Val$1={{qtm1},{rtm1},{rutm1}};
ztVal$1={{zz}}/.ha[[2,1]]//numIt;
ztp1Val$1={{0}};
ztp2Val$1={{0}};
xtVal$1=bmat . xtm1Val$1 + phimat .( psiz . ztVal$1 +psieps . {{eps}} +
fmat . phimat . psiz .ztp1Val$1)//numIt;
xtp1Val$1=bmat . xtVal$1 + phimat .( psiz . ztp1Val$1 )//numIt;
xtp2Val$1=bmat . xtp1Val$1 + phimat .( psiz . ztp2Val$1 )//numIt;
hmat . Join[xtm1Val$1,xtVal$1,xtp1Val$1] -
((psiz . ztVal$1)  +(psieps . {{eps}}))//numIt;
hmat . Join[xtVal$1,xtp1Val$1,xtp2Val$1] -
((psiz . ztp1Val$1)  +(psieps . {{0}}))//numIt;




xtm1Val$2={{qtm1},{rtm1},{rutm1}};
ztVal$2={{zz}}/.ha[[3,1]]//numIt;
ztp1Val$2={{zz}}/.ha[[2,1]]/.
{eps->0,qtm1->xtVal$2[[1,1]],rutm1->xtVal$2[[3,1]]}//numIt;
ztp2Val$2={{0}};
xtVal$2=bmat . xtm1Val$2 + phimat .( psiz . ztVal$2 +psieps . {{eps}} +
fmat . phimat . psiz .ztp1Val$2)//numIt
xtp1Val$2=bmat . xtVal$2 + phimat .( psiz . ztp1Val$2 )//numIt;
xtp2Val$2=bmat . xtp1Val$2 + phimat .( psiz . ztp2Val$2 )//numIt;
hmat . Join[xtm1Val$2,xtVal$2,xtp1Val$2] -
((psiz . ztVal$2)  +(psieps . {{eps}}))//numIt
hmat . Join[xtVal$2,xtp1Val$2,xtp2Val$2] -
((psiz . ztp1Val$2)  +(psieps . {{0}}))//numIt



someVecs[[2]],bmat. someVecs[[2]]//.
((lucaSubs//myN//Expand//Chop)  - (psiz . {{zz}}/.ha[[2,1]]//.lucaSubs//myN//Expand)  -(psieps . {{eps}}))//Chop


(hmat .Join[{{qtm1},{rtm1},{rutm1}},someVecs[[3]],
(bmat. someVecs[[3]]//.
lucaSubs//myN//Expand//Chop)+
phimat . psiz . {{zz}}/.ha[[2,1]]]/.{qtm1->someVecs[[3,1,1]]/.eps->0,rutm1->someVecs[[3,3,1]]/.eps->0}//.lucaSubs//myN//Expand//Chop)






someVecs[[2]]
{zsub0,xtVal0}=compZ0[Transpose[{{qtm1,rtm1,rutm1}}],
{{eps}},{{zz}},{{0}}]//.lucaSubs//myN//Expand//Chop


{zsub1,xtVal1}=compZ0[Transpose[{{qtm1,rtm1,rutm1}}],
{{eps}},{{zz}},{{(zz/.zsub0)/.{qtm1->qt,rtm1->rt,rutm1->rut}}}]//.lucaSubs//myN//Expand//Chop






ha = {z2RHSNew/.{rUnderBar->RUB,uu$Shock->0} ,{qq, qLow, qHigh}, {ru, ruLow, ruHigh}} //. mySubs // myN
Plot3D @@ ha

ba= {(z1RHS/.{qq[t-1]->qq,ru[t-1]->ru})/.uu$Shock->.0 ,{qq, qLow, qHigh}, {ru, ruLow, ruHigh}} //. mySubs // myN
Plot3D @@ ba



duh= {(resid0/.{qq[t-1]->qq,ru[t-1]->ru})/.uu$Shock->.0 ,{qq, qLow, qHigh}, {ru, ruLow, ruHigh}} //. mySubs // myN;Plot3D @@ duh


formula verification






doPlots[rb_?NumberQ]:=
Module[{},
ba= {(z1RHS/.{qq[t-1]->qq,ru[t-1]->ru})/.uu$Shock->rb ,{qq, qLow, qHigh}, {ru, ruLow, ruHigh}} //. mySubs // myN;plt1=(Plot3D @@ ba);
ha = {z2RHSNew/.uu$Shock->rb ,{qq, qLow, qHigh}, {ru, ruLow, ruHigh}} //. mySubs // myN;(plt2=Plot3D @@ ha);
Show[GraphicsGrid[{{plt1,plt2}}]]]

*)
