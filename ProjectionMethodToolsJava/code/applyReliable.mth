(* use reliable paper formula to solve occasionally binding constraints models*)
Get["prepPackages.mth"];
PrependTo[$Path,"../../../mathAMA/SymbolicAMA"];
PrependTo[$Path,"../../../mathAMA/NumericAMA"];
PrependTo[$Path,"../../../paperProduction/mathAMA/AMAModel/"];
PrependTo[$Path,"../../../paperProduction/symbAMA/code"];
PrependTo[$Path,"../../../paperProduction/FormatOptimize/"];

Needs["AccelerateAMA`"]



Print["need code to compute psimat"]



linearizeSystemForOBC[eqns_List]:=
Module[{noCnstr=eqns/.{eps[_][_]->0,eqvdIf[_,xx_,_]->xx},zf,hr,
bmat,phimat,fmat},Print[noCnstr];
With[{hmat=equationsToMatrix[noCnstr]},Print[hmat];
{ig,ig,ig,ig,qmat,ig,ig,ig}=numericAMA[hmat,1,1];Print[zf,hf];
Print["need to generalize to actually compute qmat"];
{hmat,qmat,{bmat,phimat,fmat}=numericComputeBPhiF[hmat,qmat,1]}
]]

nonFPart[xtm1_?MatrixQ,epsilon_?MatrixQ,
bmat_?MatrixQ,phimat_?MatrixQ,psimat_?MatrixQ]:=
bmat . xtm1 + phimat . psimat . epsilon

fPart[phimat_?MatrixQ,fmat_?MatrixQ,psiz_?MatrixQ,zMats_List]:=
Plus @@ MapIndexed[ MatrixPower[fmat,(#2[[1]]-1)] . phimat. psiz . #1&,zMats]

onlyOneTimePeriod[lhsCnstrnt_?MatrixQ]:=
Length[Union[Cases[lhsCnstrnt,_[Global`t+ss_.]->ss,Infinity]]]===1

Print["assumes all variables on lhs and dated the same time period."]
cnstrntsPart[lhsCnstrnt_?MatrixQ,rhsCnstrnt_?MatrixQ]:=
With[{forTime=Cases[lhsCnstrnt,_[Global`t+ss_.]->ss,Infinity][[1]]},
MapThread[eqvdIf[#1>=#2,0,#2-#1]&,(Flatten/@{lhsCnstrnt,rhsCnstrnt})]]/;
onlyOneTimePeriod[lhsCnstrnt]

genLeadEqns[lhsCnstrns_?MatrixQ]:=
With[{vars=Cases[lhsCnstrns,xx_[Global`t+_.]:>ToString[xx],Infinity],
forTime=Cases[lhsCnstrns,_[Global`t+ss_.]->ss,Infinity][[1]]},
If[forTime<2,{},
With[{allTimes=genFutureDefs[#,forTime]&/@vars},Flatten[allTimes]
]]]/;onlyOneTimePeriod[lhsCnstrns]

doVar[vn_String,num_Integer]:=
Table[ToExpression[vn<>"$tp"<>ToString[ii]],{ii,1,num}]

doVarSubs[vn_String,num_Integer]:=
Table[ToExpression[vn<>"[Global`t+"<>ToString[ii]<>"]:>"<>vn<>"$tp"<>ToString[ii]],{ii,1,num}]

genFutureDefs[vn_String,num_Integer]:=
If[num<2,{},
With[{allVn=doVar[vn,num]},
With[{lhs=Through[allVn[Global`t]],
rhs=Prepend[Drop[Through[allVn[Global`t+1]],-1],
ToExpression[vn<>"[Global`t+1]"]]},
lhs-rhs]]]



cnstrntsPartAll[horizons_Integer,lhsCnstrnt_?MatrixQ,rhsCnstrnt_?MatrixQ]:=
With[{eqvdPart=Flatten[Table[
cnstrntsPart[lhsCnstrnt/.Global`t->Global`t+ii,rhsCnstrnt],{ii,horizons,0,-1}]],
vars=Cases[lhsCnstrnt,xx_[Global`t+_.]:>ToString[xx],Infinity],
zvars=Table[
ToExpression["zzz$"<>ToString[forTime]<>"$"<>ToString[ii]<>"[Global`t"<>"]"],{forTime,0,horizons},{ii,Length[lhsCnstrnt]}],
leqns=genLeadEqns[lhsCnstrnt/.Global`t->Global`t+horizons]},
With[{allSubs=Flatten[doVarSubs[#,horizons]&/@vars]},
{allSubs,zvars,leqns,zvars-eqvdPart/.allSubs}]]/;
Union[Cases[lhsCnstrnt,_[Global`t+ss_.]->ss,Infinity]]==={0}






lucaSubs = {betap -> 99/100, phip -> 1, rhop -> 1/2, sigmap -> 1, 
   rUnderBar -> 2/100, qLow -> -.5, qHigh -> .5, 
   ruLow -> -4*sigma$u/(1 - rho$ru), 
   ruHigh ->  4*sigma$u/(1 - rho$ru), integOrder -> {20}, 
   sigma$u -> 0.02, theMean -> {0}, rho$ru -> 0.5, adj -> 1};

lucaEqns = {qq[t] - (betap*(1 - rhop)*qq[t + 1] + rhop*qq[t - 1] - 
      sigmap*rr[t] + ru[t]),
   ru[t] - rho$ru*ru[t - 1] - adj*eps[uu][t],
   rr[t] - eqvdIf[phip*qq[t] >= rUnderBar, phip*qq[t], rUnderBar]}




{hmat,qmat,{bmat,phimat,fmat}}=augmentProjection[lucaEqns//.lucaSubs];
Print["take care of difference in projmethod order and equations to matrix"]
Print["projectionmethod order for state before nonstate"]
(*
Print["must do same for bmat phimat fmat etc"]
*)
psieps={{0},{1},{0}};
psiz={{0},{0},{1}};


nfp=nonFPart[{{qq[t-1]},{rr[t-1]},{ru[t-1]}},{{eps[uu][t]}},bmat,phimat,psieps]//Chop;

fp=fPart[phimat,fmat,psiz,{}]//Chop

eqns00=InputForm[Flatten[fp+nfp]]

mMat={{phip},{0},{0}};

cnstrntsPart[{{qq[t]}},{{0.02}}]

nfp=nonFPart[{{qq[t-1]},{rr[t-1]},{ru[t-1]}},{{eps[uu][t]}},bmat,phimat,psieps]//Chop;

fp=fPart[phimat,fmat,psiz,{{{z10[t]}},{{z9[t]}},{{z8[t]}},{{z7[t]}},{{z6[t]}},{{z5[t]}},{{z4[t]}},{{z3[t]}},{{z2[t]}},{{z1[t]}},{{z0[t]}}}]//Chop



