PrependTo[$Path,"../../../AMASeriesRepresentation/AMASeriesRepresentation/"]

occDir="../../../paperProduction/occBind/docs/"
toOccDir[fName_String]:=CopyFile[fName,occDir <>fName,OverwriteTarget -> True];


Get["prepSimple.mth"]

Get["genArbLin.mth"]

trueVal=Flatten[simpRBCExactDR @@ anXEps]
numVals=30;

genSeriesReps[linMod:{hMat_?MatrixQ,BB_?MatrixQ,phi_?MatrixQ,FF_?MatrixQ,psiEps_?MatrixQ,psiC_?MatrixQ,psiZ_?MatrixQ,psiZPreComp_?MatrixQ},
	initVec_?VectorQ,allArgs:{expctSpec:{{_Symbol,_}..},opts_:{}},theExactDR:(_Function|_CompiledFunction),maxIters_Integer]:=
{huh,vals}=Timing[bunchOfREs=nestIterREInterp[linMod,{X0Z0},{{}},
Private`rbcEqnsFunctionalNext,aGSpec,theDist,15]];





arbMod = genSeriesReps[notLinMod,anXEps, theDist, 
   simpRBCExactDR, numVals];
theArbZs=genZsREExact[nothmat,notLinMod,anXEps,theDist,simpRBCExactDR,numVals];
arbErrMatNorms=Norm[truncErrorMat[notLinMod[[3]],notLinMod[[2]],#-1] ,Infinity]&/@Range[numVals]


arbRes={arbErrMatNorms[[#]],Norm[theArbZs[[#]],Infinity],
arbErrMatNorms[[#]]*Norm[theArbZs[[#]],Infinity],
Norm[Flatten[arbMod[[#,{4,5,6}]]-trueVal],Infinity]}& /@ Range[numVals];

Export["arbBoundsVActual.pdf",ListPlot[Transpose[arbRes[[All,{-2,-1}]]],
PlotStyle->{Red,Blue},
PlotRange->All,PlotJoined->True,
PlotLegends->{Text[Subscript[B,n]],Text[Subscript[Z,n]]},
PlotLabel->"Arbitrary Linear Model: Bounds versus Actual"]]

toOccDir/@{
"arbBoundsVActual.pdf"
};







simpMod = 
  genSeriesReps[ linMod,anXEps, theDist, 
   simpRBCExactDR, numVals];
theSimpZs=genZsREExact[Private`hmatSymbRE,linMod,anXEps,theDist,simpRBCExactDR,numVals];
simpErrMatNorms=Norm[truncErrorMat[notLinMod[[3]],notLinMod[[2]],#],Infinity]&/@Range[numVals]




simpRes={simpErrMatNorms[[#]],Norm[theSimpZs[[#]],Infinity],
simpErrMatNorms[[#]]*Norm[theSimpZs[[#]],Infinity],
Norm[Flatten[simpMod[[#,{4,5,6}]]-trueVal],Infinity]}& /@ Range[numVals];



Export["simpBoundsVActual.pdf",ListPlot[Transpose[simpRes[[All,{-2,-1}]]],
PlotStyle->{Red,Blue},
PlotRange->All,
PlotJoined->True,
PlotLegends->{Text[Subscript[B,n]],Text[Subscript[Z,n]]},
PlotLabel->"Linearized RBC Model: Bounds versus Actual"]]

toOccDir/@{
"simpBoundsVActual.pdf"
};

Get["prepBetter.mth"]

exactEvalInterp = makeDREvalInterp[betterExactDR, theDist,
Private`rbcEqnsFunctionalNext,aGSpec]

Export["exactNormErrorZeroEQ"<>#<>".pdf",
Plot3D[exactEvalInterp[.1, xx, 1, yy, 0][[ToExpression[#]]], 
{xx, kLow, kHigh}, {yy, thLow,   thHigh},PlotLabel->"Numerical Error Iterating and Integrating\n the Exact RBC Decision Rule: equation "<>#]]& /@(ToString/@Range[4])


toOccDir/@{
"exactNormErrorZeroEQ1.pdf",
"exactNormErrorZeroEQ2.pdf",
"exactNormErrorZeroEQ3.pdf",
"exactNormErrorZeroEQ4.pdf"
};



FindMaximum[{Norm[exactEvalInterp[.1, xx, 1, yy, 0]], 
  kLow <= xx <= kHigh && thLow <= yy <= thHigh}, {xx, yy}]



approxExactDR=Private`makeInterpFunc[betterExactDR,aGSpec];


approxEvalInterp = makeDREvalInterp[approxExactDR, theDist,
Private`rbcEqnsFunctionalNext,aGSpec]


Export["approxNormErrorZeroEQ"<>#<>".pdf",
Plot3D[approxEvalInterp[.1, xx, 1, yy, 0][[ToExpression[#]]], 
{xx, kLow, kHigh}, {yy, thLow,   thHigh},PlotRange->All,PlotLabel->"Numerical Error Iterating and Integrating\n the Approx RBC Decision Rule: equation "<>#]]& /@(ToString/@Range[4])



numNodes=15
betterGSpec={{1, 3}, 1, 
{{numNodes, 0.018732441104784652, 0.7492976441913861}, 
{numNodes, 9/10, 11/10}, 
{numNodes, -0.03, 0.09}}}


betterApproxExactDR=Private`makeInterpFunc[betterExactDR,betterGSpec];


betterApproxEvalInterp = makeDREvalInterp[betterApproxExactDR, theDist,
Private`rbcEqnsFunctionalNext,betterGSpec]


Export["betterApproxNormErrorZeroEQ"<>#<>".pdf",
Plot3D[betterApproxEvalInterp[.1, xx, 1, yy, 0][[ToExpression[#]]], 
{xx, kLow, kHigh}, {yy, thLow,   thHigh},PlotRange->All,PlotLabel->"Numerical Error Iterating and Integrating\n the BetterApprox RBC Decision Rule: equation "<>#]]& /@(ToString/@Range[4])







numNodes=30
betterGSpec={{1, 3}, 1, 
{{numNodes, 0.018732441104784652, 0.7492976441913861}, 
{numNodes, 9/10, 11/10}, 
{numNodes, -0.03, 0.09}}}


betterApproxExactDR=Private`makeInterpFunc[betterExactDR,betterGSpec];


betterApproxEvalInterp = makeDREvalInterp[betterApproxExactDR, theDist,
Private`rbcEqnsFunctionalNext,betterGSpec]


Export["betterApproxNormErrorZeroEQ"<>#<>".pdf",
Plot3D[betterApproxEvalInterp[.1, xx, 1, yy, 0][[ToExpression[#]]], 
{xx, kLow, kHigh}, {yy, thLow,   thHigh},PlotRange->All,PlotLabel->"Numerical Error Iterating and Integrating\n the BetterApprox RBC Decision Rule: equation "<>#]]& /@(ToString/@Range[4])




numNodes=45
betterGSpec={{1, 3}, 1, 
{{numNodes, 0.018732441104784652, 0.7492976441913861}, 
{numNodes, 9/10, 11/10}, 
{numNodes, -0.03, 0.09}}}


betterBetterBetterApproxExactDR=Private`makeInterpFunc[betterExactDR,betterGSpec];


betterBetterBetterApproxEvalInterp = makeDREvalInterp[betterBetterBetterApproxExactDR, theDist,Private`rbcEqnsFunctionalNext,betterGSpec]


Export["betterBetterBetterApproxNormErrorZeroEQ"<>#<>".pdf",
Plot3D[betterBetterBetterApproxEvalInterp[.1, xx, 1, yy, 0][[ToExpression[#]]], 
{xx, kLow, kHigh}, {yy, thLow,   thHigh},PlotRange->All,PlotLabel->"Numerical Error Iterating and Integrating\n the BetterBetterBetterApprox RBC Decision Rule: equation "<>#]]& /@(ToString/@Range[4])

(*

evalExpctPathErrDRREIntegrate[betterExactDR,anX,theDist,Private`rbcEqnsFunctionalNext]
Private`worstPathForErrDRREIntegrate[betterExactDR,anX,theDist,Private`rbcEqnsFunctionalNext]

bp=evalBadPathErrDRREIntegrate[betterExactDR,anX,theDist,Private`rbcEqnsFunctionalNext]
badXEps=Append[anX,bp[[2,-1,-1]]]
Norm[evalPathErrDRREIntegrate[betterExactDR,badXEps,theDist,Private`rbcEqnsFunctionalNext],Infinity]

betterApproxEvalInterp = makeDREvalInterp[betterApproxExactDR, theDist,Private`rbcEqnsFunctionalNext,betterGSpec]





anApproxEvalInterp = makeDREvalInterp[betterApproxExactDR, theDist,Private`rbcEqnsFunctionalNext,aGSpec];
thePts=Private`gridPts[aGSpec[[3]]]
evalPathErrDRREIntegrate[betterExactDR,Sequence[#],theDist,Private`rbcEqnsFunctionalNext]&/@thePts


evalPathErrDRREIntegrate[betterExactDR,Private`fillIn[{{},{1,3},#}],theDist,Private`rbcEqnsFunctionalNext]&/@(thePts[[{1,2}]])

(anApproxEvalInterp@@Private`fillIn[{{},{1,3},#}])&/@(thePts[[{1,2}]])
numTerms=4;

genTruncFunc[numTerms_Integer]:=
Function[{ig,kv,ig2,tv,ev},With[{aSer=
Private`genASeriesRep[linMod,{ig,kv,ig2,tv,ev},genZsREExact[Private`hmatSymbRE,linMod,{ig,kv,ig2,tv,ev},theDist,betterExactDR,numTerms],numTerms]},aSer[[{5,6,7,8}]]]]


numNodes=15
betterGSpec={{1, 3}, 1, 
{{numNodes, 0.018732441104784652, 0.7492976441913861}, 
{numNodes, 9/10, 11/10}, 
{numNodes, -0.03, 0.09}}}


numTerms=20;
{truncEvalInterp,truncEval} = 
makeDREvalInterp[genTruncFunc[numTerms], theDist,Private`rbcEqnsFunctionalNext,betterGSpec]

Export["ugly0NormErrorZeroEQ"<>#<>".pdf",
Plot3D[truncEvalInterp[.1, xx, 1, yy, 0][[ToExpression[#]]], 
{xx, kLow, kHigh}, {yy, thLow,   thHigh},PlotRange->All,PlotLabel->"Numerical Error Iterating and Integrating\n the BetterBetterBetterApprox RBC Decision Rule: equation "<>#]]& /@(ToString/@Range[4])




Needs["DifferentialEquations`InterpolatingFunctionAnatomy`"];


*)





